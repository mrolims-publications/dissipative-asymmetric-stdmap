import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import sys
from numba import njit, vectorize

@njit
def map(x_ini: np.float64, y_ini: np.float64, k: np.float64, a: np.float64, gamma: np.float64) -> np.ndarray:
    """
    Computes the updated values of `x` and `y` based on the initial values and given parameters
    of the dissipative asymmetric kicked rotor map (DAKRM).

    This function applies a transformation to the initial values `x_ini` and `y_ini`
    using the parameters `k`, `a`, and `gamma`, and returns the updated values 
    as a NumPy array.

    This function uses Numba's `njit` decorator for performance optimization.

    Parameters
    ----------
    x_ini : np.float64
        Initial value of `x`.
    y_ini : np.float64
        Initial value of `y`.
    k : np.float64
        Control parameter affecting the integrability of the system.
    a : np.float64
        Control parameter affecting the asymmetry of the system.
    gamma : np.float64
        Control parameter affecting the damping of the system.

    Returns
    -------
    np.ndarray
        A NumPy array containing the updated values of `x` and `y`, where:
        - The first element is the updated `x` value.
        - The second element is the updated `y` value.

    Examples
    --------
    >>> map(1.0, 0.5, 2.0, 0.3, 0.1)
    array([2.56637061, 1.56637061])
    """
    y = (1 - gamma) * y_ini + k * (np.sin(x_ini) + a * np.sin(2 * x_ini + np.pi / 2))
    x = (x_ini + y) % (2 * np.pi)

    return np.array([x, y])

@njit
def time_series(x_ini: np.float64, y_ini: np.float64, k: np.float64, a: np.float64, gamma: np.float64, t_trans: np.int32, t_end: np.int32) -> np.ndarray:
    """
    Generates a time series of `x` and `y` values based on the initial conditions and given
    parameters for the dissipative asymmetric kicked rotor map (DAKRM).

    This function simulates the evolution of the system starting from the initial values `x_ini`
    and `y_ini` using the parameters `k`, `a`, and `gamma`. The function first performs a 
    transient phase over `t_trans` iterations to reach a stable state and then generates 
    the time series of length `t_end - t_trans`.

    This function uses Numba's `njit` decorator for performance optimization.

    Parameters
    ----------
    x_ini : np.float64
        Initial value of `x`.
    y_ini : np.float64
        Initial value of `y`.
    k : np.float64
        Control parameter affecting the integrability of the system.
    a : np.float64
        Control parameter affecting the asymmetry of the system.
    gamma : np.float64
        Control parameter affecting the damping of the system.
    t_trans : np.int32
        Number of transient iterations to discard before recording the time series.
    t_end : np.int32
        Total number of iterations to run, including the transient phase.

    Returns
    -------
    np.ndarray
        A 2D NumPy array of shape `(t_end - t_trans, 2)`, where each row represents
        the values of `x` and `y` at each time step after the transient phase.
    """
    sample_size = t_end - t_trans
    u = np.zeros((sample_size, 2))
    x = x_ini
    y = y_ini

    for j in range(t_trans):
        x, y = map(x, y, k, a, gamma)
    
    for j in range(sample_size):
        x, y = map(x, y, k, a, gamma)
        u[j, 0] = x
        u[j, 1] = y
    
    return u

@vectorize(["i8(f8, f8, f8, f8, f8, i8, i8)"],
           nopython=True,
           target="parallel")
def period_counter(x_ini: np.float64, y_ini: np.float64, k: np.float64, a: np.float64, gamma: np.float64, t_trans: np.int32, t_end: np.int32) -> np.int32:
    """
    Determines the period of a given initial condition for the specified parameters.

    This function calculates the period of the time series generated by the `time_series`
    function, checking whether the `x` and `y` values repeat after a certain number of 
    iterations. The period is defined as the number of iterations after which both `x` 
    and `y` return to their initial values simultaneously.

    Parameters
    ----------
    x_ini : np.float64
        Initial value of `x`.
    y_ini : np.float64
        Initial value of `y`.
    k : np.float64
        Control parameter affecting the integrability of the system.
    a : np.float64
        Control parameter affecting the asymmetry of the system.
    gamma : np.float64
        Control parameter affecting the damping of the system.
    t_trans : np.int32
        Number of transient iterations to discard before recording the time series.
    t_end : np.int32
        Total number of iterations to run, including the transient phase.

    Returns
    -------
    np.int32
        The period of the system if `x` and `y` values repeat simultaneously, 
        otherwise returns -1 if no common period is found.

    Notes
    -----
    The function operates in parallel mode using the `@vectorize` decorator, 
    and uses the `time_series` function to generate the time series.
    """
    u = time_series(x_ini, y_ini, k, a, gamma, t_trans, t_end)
    period_x = []
    period_y = []
    px = 1
    py = 1
    for j in range(1, u.shape[0]):

        if abs(u[0, 0] - u[j, 0]) < 1e-10:
            period_x.append(px)
            px = 0
        if abs(u[0, 1] - u[j, 1]) < 1e-10:
            period_y.append(py)
            py = 0

        px += 1
        py += 1

    if len(period_y) != 0 and len(period_x) != 0 and period_x == period_y:        
        return period_x[0]
    else:
        return int(-1)
    
@vectorize(["f8(f8, f8, f8, f8, f8, i8, i8)"],
           nopython=True,
           target="parallel")
def lyapunov(x_ini: np.float64, y_ini: np.float64, k: np.float64, a: np.float64, gamma: np.float64, t_trans: np.int32, t_end: np.int32) -> np.float64:
    """
    Computes the Lyapunov exponent for given initial condition `x_ini` and `y_ini` for the
    specified parameters.

    The Lyapunov exponent measures the average rate of divergence or convergence of nearby trajectories
    in the system's phase space. The function uses the eigenvalues of the Jacobian matrix to compute the
    largest Lyapunov exponent according to Eckmann and Ruelle's method.

    Parameters
    ----------
    x_ini : np.float64
        Initial value of `x`.
    y_ini : np.float64
        Initial value of `y`.
    k : np.float64
        Control parameter affecting the integrability of the system.
    a : np.float64
        Control parameter affecting the asymmetry of the system.
    gamma : np.float64
        Control parameter affecting the damping of the system.
    t_trans : np.int32
        Number of transient iterations to discard before recording the Lyapunov exponent.
    t_end : np.int32
        Total number of iterations to run, including the transient phase.

    Returns
    -------
    np.float64
        The Lyapunov exponent of the system. A positive value indicates chaos, while a negative value 
        indicates stability.

    Notes
    -----
    The function operates in parallel mode using the `@vectorize` decorator. 
    It computes the Lyapunov exponent by iterating through the time series generated by 
    the `map` function, using the Jacobian matrix of the system.

    The calculation assumes the system is two-dimensional, with `x` and `y` as the state variables.
    """
    x = x_ini
    y = y_ini
    beta0 = 0
    lypnv = 0
    J = np.zeros((2, 2)) # Jacobian matrix
    for j in range(t_trans):
        x, y = map(x, y, k, a, gamma)
    for j in range(int(t_end - t_trans)):
        x, y = map(x, y, k, a, gamma)
        J[0, 0] = 1 + k*(np.cos(x) + 2*a*np.cos(2*x + np.pi/2))
        J[0, 1] = 1 - gamma
        J[1, 0] = k*(np.cos(x) + 2*a*np.cos(2*x + np.pi/2))
        J[1, 1] = 1 - gamma
        beta = np.arctan((- J[1, 0] * np.cos(beta0) + J[1, 1] * np.sin(beta0)) / (J[0, 0] * np.cos(beta0) - J[0, 1] * np.sin(beta0)))
        T11 = np.cos(beta0) * (J[0, 0] * np.cos(beta) - J[1, 0] * np.sin(beta)) - np.sin(beta0)*(J[0, 1] * np.cos(beta) - J[1, 1] * np.sin(beta))
        lypnv += np.log(abs(T11))/np.log(2)
        beta0 = beta

    lypnv /= (t_end - t_trans)

    return lypnv

def get_params(idntf: str):
    """
    Returns the gamma value and parameter limits based on the provided identifier.

    This function selects specific values for the damping parameter (`gamma`) and a list of 
    limits based on the input identifier (`idntf`). The limits represent ranges for k and a,
    i.e., limits = [k_ini, k_end, a_ini, a_end].

    Parameters
    ----------
    idntf : str
        Identifier string that determines the set of parameters to return. 
        Accepted values include:
        - "1"
        - "2a", "2b", "2c", "2d"
        - "3", "3a", "3b", "3c", "3d"
        - "3amag", "3bmag", "3cmag", "3dmag"

    Returns
    -------
    gamma : float
        The damping parameter corresponding to the provided identifier.
    limits : list of float
        A list of four float values representing parameter limits.

    Raises
    ------
    SystemExit
        If the provided identifier is invalid, the function prints an error message and exits.

    Examples
    --------
    >>> gamma, limits = get_params("1")
    >>> print(gamma)
    0.8
    >>> print(limits)
    [0, 30, 0, 1]

    >>> gamma, limits = get_params("3bmag")
    >>> print(gamma)
    0.85
    >>> print(limits)
    [114, 128, 0.26, 0.32]
    """
    if idntf == "1":
        limits = [0, 30, 0, 1]
        gamma = 0.80
    elif idntf == "2a":
        limits = [14, 17, 0.35, 0.5]
        gamma = 0.80
    elif idntf == "2b":
        limits = [14.7, 15.4, 0.145, 0.185]
        gamma = 0.80
    elif idntf == "2c":
        limits = [9.4, 10.2, 0.13, 0.18]
        gamma = 0.80
    elif idntf == "2d":
        limits = [2, 4, 0.2, 0.55]
        gamma = 0.80
    elif "3" in idntf:
        if "mag" not in idntf:
            limits = [0, 200, 0, 1]
        else:
            limits = [114, 128, 0.26, 0.32]
        if "3a" in idntf:                
            gamma = 0.80
        elif "3b" in idntf:                
            gamma = 0.85
        elif "3c" in idntf:                
            gamma = 0.90
        elif "3d" in idntf:                
            gamma = 0.95            
    else:
        print("Invalid idntf")
        sys.exit()
    
    return gamma, limits

def plot_params(fontsize: np.int32 = 20, legend_fontsize: np.int32 = 14, axes_linewidth: np.float64 = 1.3) -> list:
    """
    Configures the plot parameters for Matplotlib figures.

    This function sets various global plotting parameters, including font sizes, 
    axis line widths, and font families, to customize the appearance of Matplotlib plots.

    Parameters
    ----------
    fontsize : np.int32, optional
        The font size for the main text in the plot. The default is 20.
    legend_fontsize : np.int32, optional
        The font size for the legend text in the plot. The default is 14.
    axes_linewidth : np.float64, optional
        The line width for the axes. The default is 1.3.

    Returns
    -------
    list
        A list containing the set values `[fontsize, legend_fontsize, axes_linewidth]`.

    Notes
    -----
    This function uses Matplotlib's `plt.rc` and `plt.rcParams` to set the parameters 
    globally, affecting all subsequent plots. The `mathtext.fontset` is set to 'stix' 
    for consistency with LaTeX-style math rendering.
    """
    tick_labelsize = fontsize - 3
    plt.clf()
    plt.rc('font', size=fontsize)
    plt.rc('xtick', labelsize=tick_labelsize)
    plt.rc('ytick', labelsize=tick_labelsize)
    plt.rc('legend', fontsize=legend_fontsize)
    font = {'family' : 'stix'}
    plt.rc('font', **font)
    plt.rcParams["mathtext.fontset"] = "stix"
    mpl.rcParams['axes.linewidth'] = axes_linewidth #set the value globally

    return [fontsize, legend_fontsize, axes_linewidth]

def format_number(x: np.float64, decimal_places: np.int32 = 5) -> str:
    """
    Formats a floating-point number to a string with a specified number of decimal places.

    This function converts a floating-point number to a string, formatted to the specified 
    number of decimal places. It removes the leading zero for positive values that are less 
    than 1, and for negative values that are less than -1.

    Parameters
    ----------
    x : np.float64
        The floating-point number to be formatted.
    decimal_places : np.int32, optional
        The number of decimal places to include in the formatted string. 
        The default is 5.

    Returns
    -------
    str
        The formatted number as a string, with the specified number of decimal places 
        and without a leading zero if the value is between -1 and 1.

    Examples
    --------
    >>> format_number(0.123456789)
    '.12346'

    >>> format_number(-0.987654321, decimal_places=3)
    '-.988'

    >>> format_number(123.456)
    '123.45600'
    
    >>> format_number(-123.456)
    '-123.45600'

    Notes
    -----
    The function handles both positive and negative values, ensuring that leading zeros 
    are removed when the absolute value of the input is less than 1.
    """
    formatted = f"{x:.{decimal_places}f}"
    if formatted.startswith('0'):
        formatted = formatted[1:]
    elif formatted.startswith("-0"):
        formatted = formatted[0] + formatted[2:]
    return formatted

def extract_grid(datafile: str):
    """
    Extracts and reshapes data from a file into 2D grids for `x`, `y`, and `z` coordinates.

    This function reads a space-delimited file containing `x`, `y`, and `z` values, and 
    reshapes these values into 2D arrays (grids). It assumes that the data represents a 
    square grid, where the number of points is a perfect square.

    Parameters
    ----------
    datafile : str
        The path to the file containing the `x`, `y`, and `z` data. The file should 
        be space-delimited and have no header.

    Returns
    -------
    x : np.ndarray
        A 2D array representing the `x` coordinates of the grid.
    y : np.ndarray
        A 2D array representing the `y` coordinates of the grid.
    z : np.ndarray
        A 2D array representing the `z` values corresponding to the `x` and `y` coordinates.

    Examples
    --------
    >>> x, y, z = extract_grid("data.txt")
    >>> x.shape
    (100, 100)
    >>> y.shape
    (100, 100)
    >>> z.shape
    (100, 100)

    Notes
    -----
    The function assumes that the number of rows in the data file is a perfect square.
    This allows the `x`, `y`, and `z` arrays to be reshaped into square 2D grids.
    """
    df = pd.read_csv(datafile, header=None, delim_whitespace=True)
    x = np.array(df[0])
    y = np.array(df[1])
    z = np.array(df[2])
    M = int(np.sqrt(len(x)))
    x = x.reshape((M, M))
    y = y.reshape((M, M))
    z = z.reshape((M, M))

    return x, y, z